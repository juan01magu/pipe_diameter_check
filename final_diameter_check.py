# -*- coding: utf-8 -*-
"""final_diameter_check.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14_7Lfl956zsEdj5-iw0TRBFfY-z2Bt3G
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import math
import re
from scipy.optimize import fsolve
from scipy.optimize import root_scalar
from scipy.optimize import newton
import scipy.stats as stats
from scipy.signal import find_peaks

#filename = 'MC-EB-120.csv'
filename = 'MC-EB-120_perturbed.csv'
#filename = 'MC-EB-120_perturbed_2.csv'

pd.set_option('display.float_format', '{:.9f}'.format)  # Show up to 8 decimal places

# Define the columns names
original_columns = ['level', 'velocity', 'flow']
# Now you can load your data from 'your_data_file.csv'
data = pd.read_csv(filename, names=original_columns)
# Display the updated DataFrame
print("This is the head of the original data:")
print(data.head())

data_sct_level = data['level'][69000: 71000]
data_sct_velocity = data['velocity'][69000: 71000]
data_sct_flow = data['flow'][69000: 71000]

# Delete the blank spaces
data.dropna(subset=['level'], inplace=True)

# Calculate the area from the flow and velocity A = Q/V
data['area'] = data['flow'] / data['velocity']

print("This is the head of the original data plus the area:")
print(data.head())

### First 10 datapoints
dt = data.copy()
dt = dt[0:9]
def equation(D, A, d):
    """
    #Calculates the difference between the given A and the calculated A based on D and d.
    #Returns:
    #    The difference between the given A and the calculated A.
    """
    if D <= 0 or d < 0 or D < (2*d):
        return float('inf')  # Return a large value if D is invalid
    try:
        arccos_term = np.arccos((D - 2 * d) / D)
        calculated_A = (D**2) / 8 * (2 * arccos_term - np.sin(2 * arccos_term))
        return calculated_A - A
    except ValueError: # handle cases where arccos returns NaN
        return float('inf')

def solve_for_D(A, d):
    """
    Returns:The value of D if a solution is found, otherwise None.
    """

    D_direct = math.sqrt(4 * A / np.pi)  # Direct calculation of D

    if d >= D_direct:
        return D_direct
    #if initial_guess is None:
    #    initial_guess = 3*d # a guess that D is greater than 2d.
     #   if A>0:
      #      initial_guess = math.sqrt(8*A) #another guess based on the D^2/8 part of the equation.
    try:
        result = fsolve(equation, 3*dt['level'].mean(), args=(A, d))
        return result[0] # fsolve returns an array with the solutions, as there is only one variable(D) there is only one solution that will be in the first position
    except (TypeError, IndexError, RuntimeError):
        return None

dt['diameter'] = dt.apply(lambda row:solve_for_D(row['area'], row['level']), axis=1) # to have it in inches
print("This is the head of the data with the diameter guess:")
print(dt.head())
mean_first10 = dt['diameter'].mean()
print("This is the diameter's mean for the first 10 points:", mean_first10)

def equation(D, A, d):
    """
    #Calculates the difference between the given A and the calculated A based on D and d.
    #Returns:
    #    The difference between the given A and the calculated A.
    """
    if D <= 0 or d < 0 or D < (2*d):
        return float('inf')  # Return a large value if D is invalid
    try:
        arccos_term = np.arccos((D - 2 * d) / D)
        calculated_A = (D**2) / 8 * (2 * arccos_term - np.sin(2 * arccos_term))
        return calculated_A - A
    except ValueError: # handle cases where arccos returns NaN
        return float('inf')

def solve_for_D(A, d):
    """
    #Returns:The value of D if a solution is found, otherwise None.
    """

    D_direct = math.sqrt(4 * A / np.pi)  # Direct calculation of D

    if d >= D_direct:
        return D_direct
    #if initial_guess is None:
    #    initial_guess = 3*d # a guess that D is greater than 2d.
     #   if A>0:
      #      initial_guess = math.sqrt(8*A) #another guess based on the D^2/8 part of the equation.
    try:
        result = fsolve(equation, mean_first10, args=(A, d))
        return result[0] # fsolve returns an array with the solutions, as there is only one variable(D) there is only one solution that will be in the first position
    except (TypeError, IndexError, RuntimeError):
        return None

data['diameter'] = data.apply(lambda row:solve_for_D(row['area'], row['level']), axis=1) * 12 # to have it in inches
print("This is the  head of the data with the diameter calculated for all the points:")
print(data.head())

# Code to convert the index to a date and a time in the year
def index_to_datetime(index):

    if not isinstance(index, int) or index < 0 or index > 105119:
        return None  # Handle out-of-range indices

    start_date = pd.to_datetime('2022-02-02 00:00')
    time_delta = pd.Timedelta(minutes=5)

    date_time = start_date + time_delta * index
    return date_time


def format_datetime(datetime_obj):
    #"""Formats a datetime object into a user-friendly string."""
    if datetime_obj is None:
        return "Invalid Index"
    return datetime_obj.strftime("%Y-%m-%d %H:%M")

print(f"The mean value of D is: {data['diameter'].mean()}")
print(f"The median value of D is: {data['diameter'].median()}")
print(f"The standard deviation of D is: {data['diameter'].std()}")
print(f"The minimum value of D is: {data['diameter'].min()}")
print(f"The maximum value of D is: {data['diameter'].max()}")

if data['diameter'].std() > 0.01*data['diameter'].median():
    print("Warning")


plt.figure(figsize=(8, 5))
plt.plot(data.index, data['diameter'], label='Diameter', color='b', alpha=0.7)
plt.xlabel('Time (Index)')
plt.ylabel('Diameter')
#plt.xlim(72000, 73000)
plt.title(filename)
plt.legend()
plt.grid()
plt.show()


print("The time axis starts at: ", format_datetime(index_to_datetime(35900)))
print("The time axis ends at: ", format_datetime(index_to_datetime(36200)))

# Plot histogram
plt.hist(data['diameter'], bins=50, color='gray', alpha=0.5, edgecolor='black')
plt.xlabel("Value")
plt.ylabel("Frequency")
plt.title("Histogram of Data Distribution")
plt.show()

# Estimate means by taking peaks in histogram
counts, bin_edges = np.histogram(data['diameter'], bins=50)
peak_indices = np.argsort(counts)[-2:]  # Find the two highest frequency bins

bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
#estimated_means = (bin_edges[peak_indices] + bin_edges[peak_indices + 1]) / 2
estimated_means = bin_edges[peak_indices]

if estimated_means[0] < 0.9 * mean_first10 or estimated_means[0] > 1.1 * mean_first10:
    first_value = estimated_means[0]
    estimated_means[0] = estimated_means[1]
    estimated_means[1] = first_value


print("Estimated Means:", estimated_means)

def detect_division_indexes(data, column_name, jump_threshold=0.5, stability_len=1000, mean_threshold=0.1, return_check_window=288):
    values = data[column_name].values
    division_indices = []
    i = 0
    while i < len(values) - stability_len:
        current_val = values[i]
        next_val = values[i + 1]
        diff = abs(current_val - next_val)

        # Check for a significant jump
        if diff >= jump_threshold:
            new_segment1 = values[i + 1 : i + 1 + stability_len]
            new_segment2 = values[i + 1 - stability_len: i + 1]
            new_mean1 = np.mean(new_segment1)
            new_mean2 = np.mean(new_segment2)
            mean_diff = abs(new_mean1 - new_mean2)

            if min(abs(new_mean1/new_mean2 - 1), abs(new_mean2/new_mean1 - 1)) > mean_threshold:
                print(f"Index: {i}, new_mean1: {new_mean1}, new_mean2: {new_mean2}, mean_diff: {mean_diff}")
                division_indices.append(i)
                i += stability_len  # Skip past stable region
                continue

        i += 1

    return division_indices

division_index = detect_division_indexes(data, 'diameter')
print("Division Indexes:", division_index)

"""# Run this code only if the histogram shows 2 means and there is at least one division index = There is at least one diameter change"""

# Solving when D is not constant and has either 1 or 2 division indexes
if len(division_index) == 1:
      dt1 = data.copy()
      dt1 = dt1[0:division_index[0]]

      def solve_for_D1(A, d):
          """
          Returns:The value of D if a solution is found, otherwise None.
          """

          D_direct = math.sqrt(4 * A / np.pi)  # Direct calculation of D

          if d >= D_direct:
              return D_direct
          #if initial_guess is None:
          #    initial_guess = 3*d # a guess that D is greater than 2d.
          #   if A>0:
            #      initial_guess = math.sqrt(8*A) #another guess based on the D^2/8 part of the equation.
          try:
              result = fsolve(equation, estimated_means[0], args=(A, d))
              return result[0] # fsolve returns an array with the solutions, as there is only one variable(D) there is only one solution that will be in the first position
          except (TypeError, IndexError, RuntimeError):
              return None

      dt2 = data.copy()
      dt2 = dt2[division_index[0] + 1:]
      def solve_for_D2(A, d):
          """
          Returns:The value of D if a solution is found, otherwise None.
          """

          D_direct = math.sqrt(4 * A / np.pi)  # Direct calculation of D

          if d >= D_direct:
              return D_direct
          #if initial_guess is None:
          #    initial_guess = 3*d # a guess that D is greater than 2d.
          #   if A>0:
            #      initial_guess = math.sqrt(8*A) #another guess based on the D^2/8 part of the equation.
          try:
              result = fsolve(equation, estimated_means[1], args=(A, d))
              return result[0] # fsolve returns an array with the solutions, as there is only one variable(D) there is only one solution that will be in the first position
          except (TypeError, IndexError, RuntimeError):
              return None

      dt1['Diam'] = dt1.apply(lambda row:solve_for_D1(row['area'], row['level']), axis=1) # to have it in inches
      dt2['Diam'] = dt2.apply(lambda row:solve_for_D2(row['area'], row['level']), axis=1) # to have it in inches

elif len(division_index) == 2 and len(estimated_means) == 2:
      dt1 = data.copy()
      dt1 = dt1[0:division_index[0]]

      def solve_for_D1(A, d):
          """
          Returns:The value of D if a solution is found, otherwise None.
          """

          D_direct = math.sqrt(4 * A / np.pi)  # Direct calculation of D

          if d >= D_direct:
              return D_direct
          #if initial_guess is None:
          #    initial_guess = 3*d # a guess that D is greater than 2d.
          #   if A>0:
            #      initial_guess = math.sqrt(8*A) #another guess based on the D^2/8 part of the equation.
          try:
              result = fsolve(equation, estimated_means[0], args=(A, d))
              return result[0] # fsolve returns an array with the solutions, as there is only one variable(D) there is only one solution that will be in the first position
          except (TypeError, IndexError, RuntimeError):
              return None

      dt2 = data.copy()
      dt2 = dt2[division_index[0]:division_index[1]]
      def solve_for_D2(A, d):
          """
          Returns:The value of D if a solution is found, otherwise None.
          """

          D_direct = math.sqrt(4 * A / np.pi)  # Direct calculation of D

          if d >= D_direct:
              return D_direct
          #if initial_guess is None:
          #    initial_guess = 3*d # a guess that D is greater than 2d.
          #   if A>0:
            #      initial_guess = math.sqrt(8*A) #another guess based on the D^2/8 part of the equation.
          try:
              result = fsolve(equation, estimated_means[1], args=(A, d))
              return result[0] # fsolve returns an array with the solutions, as there is only one variable(D) there is only one solution that will be in the first position
          except (TypeError, IndexError, RuntimeError):
              return None

      dt3 = data.copy()
      dt3 = dt3[division_index[1]:]

      dt1['Diam'] = dt1.apply(lambda row:solve_for_D1(row['area'], row['level']), axis=1) # to have it in inches
      dt2['Diam'] = dt2.apply(lambda row:solve_for_D2(row['area'], row['level']), axis=1) # to have it in inches
      dt3['Diam'] = dt3.apply(lambda row:solve_for_D1(row['area'], row['level']), axis=1) # to have it in inches

# Plot the Diameter of the pipe over time
if len(division_index) > 0:
  plt.figure(figsize=(8, 5))
  plt.plot(dt1.index, dt1['Diam'], label='Diameter 1', color='b', alpha=0.7)
  plt.plot(dt2.index, dt2['Diam'], label='Diameter 2', color='r', alpha=0.7)
if len(division_index) == 2 and len(estimated_means) == 2:
    plt.plot(dt3.index, dt3['Diam'], label='Diameter 1', color='b', alpha=0.7)
plt.xlabel('Time (Index)')
plt.ylabel('Diameter')
#plt.xlim(69980, 70000)
plt.title(filename)
plt.legend()
plt.grid()
plt.show()

data_sct_diam = data['diameter'][69000: 71000]

plt.figure(figsize=(8, 5))
plt.plot(data_sct_level,data_sct_diam, label='Diameter',marker='o',linestyle='None', alpha=0.7)
plt.xlabel('LEVEL')
plt.ylabel('Diameter')
plt.title(filename)
plt.legend()
plt.grid()
plt.show()

plt.figure(figsize=(9, 6))
plt.plot(data_sct_level, data_sct_flow, marker='o', linestyle='None', alpha=0.7)
plt.xlabel('Level')
plt.ylabel('Flow')
plt.title(filename)
plt.legend()
plt.grid()
plt.show()